---
title: 牛客习题
date: 2024-10-14 9:56:04
categories:
  - exercise
  - acm
tags: [算法练习]
index_img:
banner_img: /images/壁纸.jpg
---

### 小红的red计数

题目描述：
&nbsp;&nbsp;&nbsp;&nbsp;小红拿到了一个字符串。她有若干次询问，每次询问：若翻转第 `l` 个字符到第 `r` 个字符对应的区间，该字符串有多少“red”子序列。子序列指按照原顺序取若干字符（可以不连续）形成的新字符串。每次询问后小红并不会真正翻转区间。

输入描述：
&nbsp;&nbsp;&nbsp;&nbsp;第一行输入两个整数 `n` 和 `q`，代表字符串长度和询问次数。  
&nbsp;&nbsp;&nbsp;&nbsp;第二行输入一个长度为 `n` 的，仅由小写字母组成的字符串。  
&nbsp;&nbsp;&nbsp;&nbsp;接下来的 `q` 行，每行输入两个整数 `l` 和 `r`，代表一次询问。  

输出描述：
&nbsp;&nbsp;&nbsp;&nbsp;输出 `q` 行，每行输出一个整数，代表询问的答案。

输入格式：

- 第1行：两个整数 `n, q`，表示字符串长度和询问次数。
- 第2行：一个仅由小写字母组成的字符串，长度为 `n`。
- 接下来的 `q` 行：每行两个整数 `l, r`，表示询问的区间。

输出格式：

- 输出 `q` 行，每行一个整数，表示该区间中翻转后的“red”子序列的个数。

数据范围：

- 1 ≤ `n, q` ≤ $10^5$
- 1 ≤ `l ≤ r ≤ n`

示例:
&nbsp;&nbsp;&nbsp;&nbsp;输入：

```
6 2
rreedd
1 2
1 6
```

&nbsp;&nbsp;&nbsp;&nbsp;输出：

```
8
0
```

代码实现：

```cpp
#include <bits/stdc++.h>
#define i64 long long
// 主要的解决函数
void solve()
{
    i64 n, q;           // n 表示字符串长度，q 表示询问次数
    std::cin >> n >> q; // 输入 n 和 q
    std::string s;
    std::cin >> s; // 输入字符串
    s = ' ' + s;   // 将字符串首位填充一个空格，方便使用1-based索引

    // 定义各类前缀和数组，用于存储不同子序列的计数
    std::vector<i64> prer(n + 1), pred(n + 1), pree(n + 1);                  // 分别存储 r, e, d 的前缀和
    std::vector<i64> prere(n + 1), preer(n + 1), preed(n + 1), prede(n + 1); // 分别存储 re, er, ed, de 的前缀和
    std::vector<i64> prered(n + 1), preder(n + 1);                           // 分别存储 red 和 der 的前缀和

    // 遍历字符串，计算所有前缀和
    for (i64 i = 1; i <= n; i++)
    {
        if (s[i] == 'r') // 当前字符是 'r'
        {
            prer[i] += 1;              // 记录 'r' 的前缀和
            preer[i] += pree[i - 1];   // 'er' 需要前面有 'e'
            preder[i] += prede[i - 1]; // 'der' 需要前面有 'de'
        }
        else if (s[i] == 'e') // 当前字符是 'e'
        {
            pree[i] += 1;            // 记录 'e' 的前缀和
            prere[i] += prer[i - 1]; // 're' 需要前面有 'r'
            prede[i] += pred[i - 1]; // 'de' 需要前面有 'd'
        }
        else if (s[i] == 'd') // 当前字符是 'd'
        {
            pred[i] += 1;              // 记录 'd' 的前缀和
            preed[i] += pree[i - 1];   // 'ed' 需要前面有 'e'
            prered[i] += prere[i - 1]; // 'red' 需要前面有 're'
        }

        // 将之前的前缀和累加到当前位置
        prer[i] += prer[i - 1];
        pree[i] += pree[i - 1];
        pred[i] += pred[i - 1];
        prere[i] += prere[i - 1];
        preer[i] += preer[i - 1];
        preed[i] += preed[i - 1];
        prede[i] += prede[i - 1];
        prered[i] += prered[i - 1];
        preder[i] += preder[i - 1];
    }

    // 以下几个 lambda 函数用于计算从 l 到 r 区间内的前缀和
    auto sumr = [&](i64 l, i64 r) -> i64
    {
        return prer[r] - prer[l - 1];
    };

    auto sume = [&](i64 l, i64 r) -> i64
    {
        return pree[r] - pree[l - 1];
    };

    auto sumd = [&](i64 l, i64 r) -> i64
    {
        return pred[r] - pred[l - 1];
    };

    auto sumre = [&](i64 l, i64 r) -> i64
    {
        return prere[r] - prere[l - 1];
    };

    auto sumer = [&](i64 l, i64 r) -> i64
    {
        return preer[r] - preer[l - 1];
    };

    auto sumed = [&](i64 l, i64 r) -> i64
    {
        return preed[r] - preed[l - 1];
    };

    auto sumde = [&](i64 l, i64 r) -> i64
    {
        return prede[r] - prede[l - 1];
    };

    auto sumred = [&](i64 l, i64 r) -> i64
    {
        return prered[r] - prered[l - 1];
    };

    auto sumder = [&](i64 l, i64 r) -> i64
    {
        return preder[r] - preder[l - 1];
    };

    // 处理每次询问
    while (q--)
    {
        i64 l, r;
        std::cin >> l >> r; // 输入询问的区间

        // 计算子区间中“red”和“der”子序列的数量
        i64 num = sumr(1, l - 1) * sumde(l, r) - sumr(1, l - 1) * sumed(l, r) - sumred(l, r) + sumder(l, r) - sumre(l, r) * sumd(r + 1, n) + sumer(l, r) * sumd(r + 1, n);

        // 输出结果
        std::cout << num + prered[n] << '\n';
    }
}

int main()
{
    std::ios::sync_with_stdio(0);
    std::cout.tie(0);
    std::cin.tie(0);

    i64 t = 1; // 测试次数
    // std::cin >> t; // 如果有多组测试数据，可以解除这行注释
    while (t--)
    {
        solve(); // 运行解决方案
    }
}

```
