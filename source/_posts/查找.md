---
title: 查找
date: 2024-11-21 10:56:04
categories:
  - note
  - 408
  - 数据结构
tags: [数据结构]
index_img:
banner_img: /images/壁纸.jpg
---

## 顺序查找和折半查找

### 顺序查找

一般线性表的顺序查找：

1. 从线性表的一端开始，逐个检查关键字是否满足给定的条件;
2. 若查找到某个元素的关键字满足给定条件，则查找成功，返回该元素在线性表中的位置:
3. 若已经查找到表的另一端，但还没有查找到符合给定条件的元素，则返回查找失败的信息。

有序线性表的顺序查找：

&nbsp;&nbsp;&nbsp;&nbsp;因为是有序的，因此不需要遍历全部元素，当比前一个元素大，比后一个元素小即为查询失败。

### 折半查找

&nbsp;&nbsp;&nbsp;&nbsp;二分查找，适用于有序的顺序表

### 分块查找

&nbsp;&nbsp;&nbsp;&nbsp;索引顺序查找，将查找的内容分为若干子块，块内元素可以无序，但块间的元素是有序的，前一块内的所有元素都小于下一块中的最小元素，先讯在所查内容所在的块，再在块内进行寻找

## 树形查找

### 二叉排序树（BST）

特点（左中右的中序为升序序列）：

- **左大根堆**：若左子树非空，则左子树上所有结点的值均小于根结点的值。
- **右小根堆**：若右子树非空，则右子树上所有结点的值均大于根结点的值。
- 左、右子树也分别是一棵二叉排序树。

查找：小于根结点往左，大于根结点往右

插入：左右往下遍历，到结点为空的地方加入

构造：类似于插入，树结点从零开始，一个数一个数的插入

删除：叶子结点直接删，不是的话，只有左子树，拿左结点补，只有右子树拿右结点补，左右子树都有的话，找在右子树上找中序第一个数补

#### 二叉排序树效率分析

&nbsp;&nbsp;&nbsp;&nbsp;最坏情况下为O(n)，全部在一边子树一直往下，平均为O(logn)，其实就是二分查找

### 平衡二叉树（AVL）

&nbsp;&nbsp;&nbsp;&nbsp;在二叉排序树的基础上保证任意结点的左右子树高度差的绝对值不超过1，左右子树的高度差称为该结点的平衡因子

> 对于任意子树，如果一边的子树没有的话，另一边有但不能忘下一层

插入：先按照二叉排序树插入，如果导致了不平衡，调整不平衡的部分（LL平衡旋转，RR平衡旋转，LR平衡旋转，RL平衡旋转）

> LL平衡旋转:在结点A的左孩子(L)的左子树(L)上插入了新结点
>
> RR平衡旋转:在结点A的右孩子(R)的右子树(R)上插入了新结点
>
> LR平衡旋转:在结点A的左孩子(L)的右子树(R)上插入了新结点
>
> RL平衡旋转:在结点A的右孩子(R)的左子树(L)上插入了新结点

构造：类似于插入，树结点从零开始，一个数一个数的插入

删除：先删除，导致了不平衡再调整

查找：与二叉排序树相同

### 红黑树

条件：

1. 每个结点或是红色，或是黑色的。
2. 根结点是黑色的。
3. 叶结点(虚构的外部结点、NUILL结点)都是黑色的。
4. 不存在两个相邻的红结点(即红结点的父结点和孩子结点均是黑色的)。
5. 对每个结点，从该结点到任意一个叶结点的简单路径上，所含黑结点的数量相同。



## B树和B+树

### B树及其基本操作

### B+树的基本概念

## 散列表（Hash）

### 散列表的基本概念

### 散列函数构造方法

### 处理冲突的方法

### 散列查找及其性能分析

